# event_management/views.py
from django.shortcuts import render, get_object_or_404, redirect
from django.core.paginator import Paginator
from django.db.models import Q
from django.utils import timezone
from .models import Event, Category
from django.views.generic import ListView
from django.contrib.postgres.search import SearchQuery, SearchRank
from django.http import HttpResponse
from datetime import timedelta
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from authentication.models import Organizer
from django.db import models  # Add this import for revenue calculation
from django.views.generic import TemplateView
from django.contrib.auth.mixins import LoginRequiredMixin
from .pricing import PricingService
from decouple import config
from django.utils.text import slugify
from django.views import View
from django.urls import reverse

# Import form only if it exists
try:
    from .forms import EventSubmissionForm, EventForm
except ImportError:
    EventSubmissionForm = None
    EventForm = None

# Import Booking model if it exists
try:
    from booking.models import Booking
except ImportError:
    Booking = None

# Import new models for multi-step creation
try:
    from .models import TicketType, PlatformPlan
except ImportError:
    TicketType = None
    PlatformPlan = None


# ============== UTILITY FUNCTIONS ==============
def add_organizer_message_once(request, message, level='warning'):
    """Add organizer-related message only once per session"""
    # Create a session key for this specific message
    message_key = f'shown_message_{hash(message)}'
    
    # Check if we've already shown this message in this session
    if not request.session.get(message_key, False):
        if level == 'warning':
            messages.warning(request, message)
        elif level == 'error':
            messages.error(request, message)
        elif level == 'info':
            messages.info(request, message)
        
        # Mark this message as shown for this session
        request.session[message_key] = True
        request.session.modified = True


# ============== PUBLIC VIEWS ==============
def event_list(request):
    # For public view, use only approved events
    if request.user.is_staff:
        # Staff can see all events
        events = Event.objects.filter(is_active=True, date__gte=timezone.now())
    else:
        # Public sees only approved events
        events = Event.public.all()  # This uses the PublicEventManager
    
    categories = Category.objects.all()
    
    # Enhanced search using PostgreSQL full-text search
    search_query = request.GET.get('search', '')
    if search_query:
        # Use PostgreSQL search if available
        try:
            search = SearchQuery(search_query)
            events = events.annotate(
                rank=SearchRank('search_vector', search)
            ).filter(search_vector=search).order_by('-rank')
        except:
            # Fallback to basic search if PostgreSQL search not available
            events = events.filter(
                Q(title__icontains=search_query) |
                Q(description__icontains=search_query) |
                Q(venue__icontains=search_query)
            )
        
    # Category filter
    category_slug = request.GET.get('category')
    if category_slug:
        events = events.filter(category__slug=category_slug)
    
    # Date range filters
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    if date_from:
        events = events.filter(date__gte=date_from)
    if date_to:
        events = events.filter(date__lte=date_to)
    
    # Price range filters
    price_min = request.GET.get('price_min')
    price_max = request.GET.get('price_max')
    if price_min:
        events = events.filter(price__gte=price_min)
    if price_max:
        events = events.filter(price__lte=price_max)
    
    # Quick filters - Using OR logic with Q objects
    selected_filters = request.GET.getlist('filter')  # Get multiple values
    
    if selected_filters:
        filter_query = Q()
        
        if 'free' in selected_filters:
            filter_query |= Q(price=0)
        if 'weekend' in selected_filters:
            filter_query |= Q(date__week_day__in=[6, 7, 1])
        if 'pet-friendly' in selected_filters:
            filter_query |= Q(pet_friendly=True)
        if 'family-friendly' in selected_filters:
            filter_query |= Q(family_friendly=True)
        if 'offers' in selected_filters:
            filter_query |= Q(has_offers=True)
        
        if filter_query:
            events = events.filter(filter_query)
    
    # Handle single filter parameter (from homepage links)
    single_filter = request.GET.get('filter')
    if single_filter and not selected_filters:  # Only apply if no multiple filters
        if single_filter == 'free':
            events = events.filter(price=0)
        elif single_filter == 'pet-friendly':
            events = events.filter(pet_friendly=True)
        elif single_filter == 'featured':
            events = events.filter(is_featured=True)
        elif single_filter == 'premium':
            events = events.filter(is_premium=True)
        elif single_filter == 'today':
            events = events.filter(date__date=timezone.now().date())
        elif single_filter == 'upcoming':
            week_from_now = timezone.now() + timedelta(days=7)
            events = events.filter(date__lte=week_from_now)
    
    # Sort
    sort = request.GET.get('sort', '-date')
    if sort in ['date', '-date', 'price', '-price', 'title']:
        events = events.order_by(sort)
    
    # Pagination
    paginator = Paginator(events, 9)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Check if advanced filters are being used
    show_advanced = any([
        date_from, date_to, price_min, price_max, 
        request.GET.get('show_advanced') == 'true'
    ])
    
    context = {
        'page_obj': page_obj,
        'categories': categories,
        'search_query': search_query,
        'selected_category': category_slug,
        'selected_filters': selected_filters,
        'total_events': paginator.count,
        'show_advanced': show_advanced,
        'current_filters': {
            'date_from': date_from,
            'date_to': date_to,
            'price_min': price_min,
            'price_max': price_max,
            'sort': sort,
        }
    }
    
    return render(request, 'event_management/event_list.html', context)


def homepage(request):
    today = timezone.now().date()
    
    # Base query for approved events only (unless staff)
    if request.user.is_staff:
        base_events = Event.objects.filter(is_active=True)
    else:
        base_events = Event.objects.filter(is_active=True, is_approved=True)
    
    context = {
        'featured_events': base_events.filter(
            is_featured=True,
            date__gte=today
        ).order_by('date')[:6],
        
        'premium_events': base_events.filter(
            is_premium=True,
            date__gte=today
        ).order_by('date')[:6],
        
        'today_events': base_events.filter(
            date__date=today
        ),
    }
    
    for event in context['featured_events']:
        event.is_today = event.date.date() == today
    
    return render(request, 'home.html', context)


def newsletter_signup(request):
    # For now, just redirect to home with a message   
    messages.success(request, "Thanks for your interest! Newsletter coming soon.")
    return redirect('home')


def event_detail(request, slug):
    # Check approval status based on user
    if request.user.is_staff:
        event = get_object_or_404(
            Event.objects.select_related('organizer', 'category'),
            slug=slug, 
            is_active=True
        )
    else:
        event = get_object_or_404(
            Event.objects.select_related('organizer', 'category'),
            slug=slug, 
            is_active=True, 
            is_approved=True
        )
    
    # Related events should also be approved for public
    if request.user.is_staff:
        related_base = Event.objects.filter(is_active=True).select_related('category')
    else:
        related_base = Event.objects.filter(is_active=True, is_approved=True).select_related('category')
    
    related_events = related_base.filter(
        category=event.category,
        date__gte=timezone.now()
    ).exclude(id=event.id)[:3]
    
    context = {
        'event': event,
        'related_events': related_events,
    }
    
    return render(request, 'event_management/event_detail.html', context)

def list_event_landing(request):
    """Landing page for listing events"""
    return render(request, 'event_management/list_event_landing.html', {})


def faq_view(request):
    """Display the FAQ page"""
    return render(request, 'faq.html')


def download_ics(request, slug):
    """Generate and download ICS file for the event"""
    # Check approval status based on user
    if request.user.is_staff:
        event = get_object_or_404(Event, slug=slug, is_active=True)
    else:
        event = get_object_or_404(Event, slug=slug, is_active=True, is_approved=True)
    
    # Create ICS content
    cal_lines = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Jersey Events//Event Calendar//EN',
        'CALSCALE:GREGORIAN',
        'METHOD:REQUEST',
        'BEGIN:VEVENT',
        f'UID:{event.id}@jersey.live',
        f'DTSTAMP:{timezone.now().strftime("%Y%m%dT%H%M%SZ")}',
        f'DTSTART:{event.date.strftime("%Y%m%dT%H%M%S")}',
    ]
    
    # Add end time (if not set, default to 2 hours after start)
    end_date = event.end_date if hasattr(event, 'end_date') and event.end_date else (event.date + timedelta(hours=2))
    cal_lines.append(f'DTEND:{end_date.strftime("%Y%m%dT%H%M%S")}')
    
    # Add event details
    description_cleaned = event.description.replace("\n", "\\n")
    location_cleaned = f'{event.venue}, {event.address}'
    
    cal_lines.extend([
        f'SUMMARY:{event.title}',
        f'DESCRIPTION:{description_cleaned}',
        f'LOCATION:{location_cleaned}',
        f'URL:{request.build_absolute_uri(event.get_absolute_url())}',
        'STATUS:CONFIRMED',
        'END:VEVENT',
        'END:VCALENDAR'
    ])
    
    # Create response
    response = HttpResponse('\r\n'.join(cal_lines), content_type='text/calendar')
    response['Content-Disposition'] = f'attachment; filename="{event.slug}.ics"'
    
    return response


class EventSearchView(View):
    """Redirect search requests to the main event list with query params"""
    
    def get(self, request):
        # Get all query parameters
        params = request.GET.copy()
        
        # Map 'q' parameter to 'search' if it exists
        if 'q' in params:
            params['search'] = params.pop('q')[0]
        
        # Build query string
        query_string = params.urlencode()
        
        # Redirect to event_list with the parameters
        if query_string:
            return redirect(f"{reverse('event_management:event_list')}?{query_string}")
        return redirect('event_management:event_list')
    
    def post(self, request):
        # Handle POST requests by converting to GET parameters
        params = request.POST.copy()
        
        # Map 'q' parameter to 'search' if it exists
        if 'q' in params:
            params['search'] = params.pop('q')[0]
        
        # Build query string
        query_string = params.urlencode()
        
        # Redirect to event_list with the parameters
        if query_string:
            return redirect(f"{reverse('event_management:event_list')}?{query_string}")
        return redirect('event_management:event_list')

# ============== ORGANIZER VIEWS ==============
# Note: These views require EventSubmissionForm to be created in forms.py

@login_required
def organizer_dashboard(request):
    """Dashboard for event organizers"""
    print(f"DEBUG: User = {request.user}, Authenticated = {request.user.is_authenticated}")
    
    try:
        organizer = request.user.organizer
        print(f"DEBUG: Found organizer = {organizer.company_name}")
        print(f"DEBUG: Is verified = {organizer.is_verified}")
        
        if not organizer.is_verified:
            # Use the utility function instead of direct message
            add_organizer_message_once(request, 
                "Your organizer account is pending verification.", 
                level='warning')
    except Organizer.DoesNotExist:
        print("DEBUG: No organizer found!")
        messages.error(request, "You need to be a verified organizer to access this page.")
        return redirect('home')
    
    # Get organizer's events
    events = Event.objects.filter(organizer=organizer).order_by('-created_at')
    
    # Calculate total revenue - adjust based on your model structure
    total_revenue = 0
    total_tickets_sold = 0
    
    for event in events:
        # Assuming you have a method to calculate revenue per event
        # If not, you might need to query Orders or Bookings
        try:
            event_revenue = event.ticket_types.aggregate(
                revenue=models.Sum(
                    models.F('price') * models.F('bookings__quantity'),
                    output_field=models.DecimalField()
                )
            )['revenue'] or 0
            total_revenue += event_revenue
            
            # Calculate tickets sold for this event
            event_tickets_sold = event.bookings.aggregate(
                total=models.Sum('quantity')
            )['total'] or 0
            total_tickets_sold += event_tickets_sold
            
            # Add these as properties to the event for the template
            event.revenue = event_revenue
            event.tickets_sold_count = event_tickets_sold
            event.total_tickets = event.ticket_types.aggregate(
                total=models.Sum('quantity')
            )['total'] or 0
        except:
            event.revenue = 0
            event.tickets_sold_count = 0
            event.total_tickets = 0
    
    # Get active events (approved and future)
    active_events = events.filter(
        is_approved=True,
        date__gte=timezone.now()
    ).count()
    
    # Get recent orders/bookings for activity feed
    if Booking:
        recent_orders = Booking.objects.filter(
            event__organizer=organizer,
            status='confirmed'  # Adjust based on your booking status field
        ).select_related('event', 'user').order_by('-created_at')[:5]
    else:
        recent_orders = []
    
    # Prepare context for the new template
    context = {
        'organizer': organizer,
        'events': events[:10],  # Show latest 10 events in the table
        'total_events': events.count(),
        'active_events': active_events,
        'total_tickets_sold': total_tickets_sold,
        'total_revenue': total_revenue,
        'recent_orders': recent_orders,
        # Keep your existing stats for backward compatibility
        'stats': {
            'total_events': events.count(),
            'approved_events': events.filter(is_approved=True).count(),
            'pending_events': events.filter(is_approved=False).count(),
            'total_tickets_sold': total_tickets_sold,
            'upcoming_events': events.filter(date__gte=timezone.now()).count(),
        }
    }
    return render(request, 'event_management/organizer_dashboard.html', context)


# ============== MULTI-STEP EVENT CREATION ==============

# event_management/views.py - Update your create_event view

@login_required
def create_event(request):
    """Create a new event with percentage-based pricing"""
    if request.method == 'POST':
        form = EventForm(request.POST, request.FILES)
        if form.is_valid():
            event = form.save(commit=False)
            event.organizer = request.user.organizer
            
            # Calculate the listing fee before saving
            fee, tier = event.calculate_listing_fee()
            
            # Save the fee information to the event
            event.listing_fee = fee
            event.listing_tier = tier
            
            # Set initial status
            if fee <= 0:
                # Free event - can go straight to review
                event.status = 'pending_review'
                event.listing_paid = True
                event.save()
                messages.success(request, "Your free event has been submitted for review!")
                return redirect('event_management:organizer_dashboard')
            else:
                # Paid event - needs payment first
                event.status = 'pending_payment'
                event.save()
                messages.success(request, 
                    f"Event created successfully! Your listing fee is £{fee:.2f} ({tier}). "
                    "Please complete payment to submit for review."
                )
                # Redirect to payment page
                return redirect('payments:pay_for_event', event_id=event.id)
    else:
        form = EventForm()
    
    return render(request, 'events/create_event.html', {
        'form': form,
        'title': 'Create Event'
    })

@login_required
def pay_for_event(request, event_id):
    """Handle payment for event listing fee"""
    event = get_object_or_404(Event, id=event_id, organizer=request.user.organizer)
    
    # Check if already paid
    if event.listing_paid:
        messages.info(request, "This event has already been paid for.")
        return redirect('event_management:organizer_dashboard')
    
    # Check if fee is 0 (shouldn't happen, but just in case)
    if event.listing_fee == 0:
        event.listing_paid = True
        event.listing_paid_at = timezone.now()
        event.status = 'pending_review'
        event.save()
        messages.success(request, "Your free event has been submitted for review!")
        return redirect('event_management:organizer_dashboard')
    
    context = {
        'event': event,
        'fee': event.listing_fee,
        'tier': event.listing_tier,
    }
    
    return render(request, 'event_management/pay_for_event.html', context)

@login_required
def event_ticket_types(request, event_id):
    """Step 2: Configure ticket types"""
    if not TicketType:
        messages.error(request, "Ticket type configuration not available.")
        return redirect('event_management:organizer_dashboard')
    
    event = get_object_or_404(Event, id=event_id, organizer=request.user.organizer)
    
    if request.method == 'POST':
        # Process ticket types
        ticket_types_data = []
        i = 0
        while f'ticket_name_{i}' in request.POST:
            if request.POST.get(f'ticket_name_{i}'):
                ticket_types_data.append({
                    'name': request.POST[f'ticket_name_{i}'],
                    'price': request.POST[f'ticket_price_{i}'],
                    'quantity': request.POST[f'ticket_quantity_{i}'],
                    'description': request.POST.get(f'ticket_description_{i}', ''),
                })
            i += 1
        
        if not ticket_types_data:
            messages.error(request, "You must configure at least one ticket type.")
            return render(request, 'event_management/event_ticket_types.html', {'event': event})
        
        # Clear existing ticket types for this event (in case of re-editing)
        TicketType.objects.filter(event=event).delete()
        
        # Save ticket types
        for data in ticket_types_data:
            TicketType.objects.create(
                event=event,
                name=data['name'],
                price=data['price'],
                quantity_available=data['quantity'],
                description=data['description'],
                sale_ends=event.end_date if hasattr(event, 'end_date') and event.end_date else event.date
            )
        
        messages.success(request, "Ticket types configured! Now choose your platform plan.")
        return redirect('event_management:choose_plan', event_id=event.id)
    
    # Get existing ticket types if any
    existing_tickets = TicketType.objects.filter(event=event) if TicketType else []
    
    context = {
        'event': event,
        'existing_tickets': existing_tickets,
        'title': f'Configure Tickets - Step 2: {event.title}'
    }
    return render(request, 'event_management/event_ticket_types.html', context)


@login_required  
def choose_plan(request, event_id):
    """Step 3: Choose platform plan"""
    if not PlatformPlan:
        messages.error(request, "Platform plans not configured.")
        return redirect('event_management:organizer_dashboard')
    
    event = get_object_or_404(Event, id=event_id, organizer=request.user.organizer)
    
    # Calculate total tickets configured for this event
    if TicketType:
        total_tickets = TicketType.objects.filter(event=event).aggregate(
            total=models.Sum('quantity_available')
        )['total'] or 0
    else:
        total_tickets = 0
    
    # Get appropriate plans based on ticket quantity
    if total_tickets <= 100:
        plans = PlatformPlan.objects.filter(is_active=True)
    elif total_tickets <= 500:
        plans = PlatformPlan.objects.filter(is_active=True, max_tickets__gte=500)
    else:
        plans = PlatformPlan.objects.filter(is_active=True, max_tickets=-1)  # Unlimited plans
    
    if request.method == 'POST':
        plan_id = request.POST.get('plan_id')
        if not plan_id:
            messages.error(request, "Please select a plan.")
            return render(request, 'event_management/choose_plan.html', {
                'event': event,
                'plans': plans,
                'total_tickets': total_tickets
            })
        
        plan = get_object_or_404(PlatformPlan, id=plan_id)
        event.platform_plan = plan
        event.save()
        
        messages.success(request, f"Platform plan '{plan.name}' selected! Proceeding to payment.")
        return redirect('event_management:pay_for_event', event_id=event.id)
    
    context = {
        'event': event,
        'plans': plans,
        'total_tickets': total_tickets,
        'title': f'Choose Plan - Step 3: {event.title}'
    }
    return render(request, 'event_management/choose_plan.html', context)


# ============== LEGACY EVENT CREATION (FALLBACK) ==============
# Keep the old single-form creation as a fallback

@login_required
def create_event_legacy(request):
    """Legacy single-form event creation"""
    if not EventSubmissionForm:
        messages.error(request, "Event creation form not configured.")
        return redirect('home')
        
    try:
        organizer = request.user.organizer
        if not organizer.is_verified:
            # Use the utility function
            add_organizer_message_once(request, 
                "Your organizer account must be verified to create events.", 
                level='error')
            return redirect('event_management:organizer_dashboard')
    except Organizer.DoesNotExist:
        messages.error(request, "You need to be a verified organizer to create events.")
        return redirect('home')
    
    if request.method == 'POST':
        form = EventSubmissionForm(request.POST, request.FILES)
        if form.is_valid():
            event = form.save(commit=False)
            if not event.slug:
                base_slug = slugify(event.title)
                if not base_slug:
                    base_slug = "event"
            event.slug = f"{base_slug}-{timezone.now().strftime('%Y%m%d%H%M%S')}"
            event.organizer = organizer
            event.is_approved = False  # Requires admin approval
            event.is_active = True
            event.save()
            
            messages.success(request, 
                f"Event '{event.title}' submitted successfully! "
                "It will be visible once approved by our team."
            )
            
            return redirect('event_management:organizer_dashboard')
    else:
        form = EventSubmissionForm()
    
    context = {
        'form': form,
        'title': 'Create New Event'
    }
    return render(request, 'event_management/event_form.html', context)


@login_required
def edit_event(request, slug):
    """Edit an existing event"""
    if not EventSubmissionForm:
        messages.error(request, "Event editing form not configured.")
        return redirect('home')
        
    event = get_object_or_404(Event, slug=slug)
    
    # Check ownership
    try:
        if event.organizer != request.user.organizer:
            messages.error(request, "You can only edit your own events.")
            return redirect('event_management:organizer_dashboard')
    except Organizer.DoesNotExist:
        messages.error(request, "You need to be an organizer to edit events.")
        return redirect('home')
    
    if request.method == 'POST':
        form = EventSubmissionForm(request.POST, request.FILES, instance=event)
        if form.is_valid():
            # If key details changed, might need re-approval
            if event.is_approved and form.has_changed():
                changes = form.changed_data
                critical_fields = ['title', 'date', 'venue', 'price']
                if any(field in changes for field in critical_fields):
                    event.is_approved = False
                    messages.warning(request, 
                        "Your event has been updated but requires re-approval due to significant changes."
                    )
            
            form.save()
            messages.success(request, "Event updated successfully!")
            return redirect('event_management:organizer_dashboard')
    else:
        form = EventSubmissionForm(instance=event)
    
    context = {
        'form': form,
        'event': event,
        'title': f'Edit Event: {event.title}'
    }
    return render(request, 'event_management/event_form.html', context)


@login_required
def delete_event(request, slug):
    """Delete an event (soft delete)"""
    event = get_object_or_404(Event, slug=slug)
    
    # Check ownership
    try:
        if event.organizer != request.user.organizer:
            messages.error(request, "You can only delete your own events.")
            return redirect('event_management:organizer_dashboard')
    except Organizer.DoesNotExist:
        return redirect('home')
    
    if request.method == 'POST':
        # Check if event has sold tickets
        if hasattr(event, 'tickets_sold') and event.tickets_sold > 0:
            messages.error(request, 
                "Cannot delete an event with sold tickets. Please contact support."
            )
            return redirect('event_management:organizer_dashboard')
        
        event.is_active = False  # Soft delete
        event.save()
        messages.success(request, f"Event '{event.title}' has been deleted.")
        return redirect('event_management:organizer_dashboard')
    
    context = {
        'event': event
    }
    return render(request, 'event_management/event_confirm_delete.html', context)


def become_organizer(request):
    """Landing page for becoming an organizer"""
    if request.user.is_authenticated:
        try:
            organizer = request.user.organizer
            messages.info(request, "You're already registered as an organizer!")
            return redirect('event_management:organizer_dashboard')
        except Organizer.DoesNotExist:
            pass
    
    return render(request, 'event_management/become_organizer.html')

@login_required
def create_paypal_order(request):
    """Create PayPal order for event listing fee"""
    if request.method == 'POST':
        event_id = request.POST.get('event_id')
        event = get_object_or_404(Event, id=event_id, organizer=request.user.organizer)
        
        # TODO: Implement PayPal integration
        # For now, we'll simulate a successful payment for testing
        
        messages.warning(request, 
            "PayPal integration is coming soon! For now, please contact support to complete payment."
        )
        
        # You can either:
        # 1. Mark as paid for testing (uncomment below)
        # event.listing_paid = True
        # event.listing_paid_at = timezone.now()
        # event.status = 'pending_review'
        # event.save()
        # messages.success(request, "Payment simulated! Your event has been submitted for review.")
        
        # 2. Or redirect back to payment page
        return redirect('event_management:pay_for_event', event_id=event.id)
    
    return redirect('event_management:organizer_dashboard')

def calculate_fee_ajax(request):
    """AJAX endpoint to calculate event fee in real-time"""
    try:
        capacity = int(request.GET.get('capacity', 0))
        price = Decimal(request.GET.get('price', '0'))
        
        if capacity <= 0:
            return JsonResponse({
                'fee': '0.00',
                'tier': 'Enter capacity',
                'percentage': '0'
            })
        
        # Import here to avoid circular imports
        from .pricing import PricingService
        
        fee, tier_name = PricingService.calculate_event_fee(
            capacity=capacity,
            is_free_event=(price <= 0),
            ticket_price=price
        )
        
        tier = PricingService.get_tier_for_capacity(capacity)
        
        return JsonResponse({
            'fee': str(fee),
            'tier': tier_name,
            'percentage': str(tier['percentage'])
        })
    except Exception as e:
        return JsonResponse({
            'error': str(e),
            'fee': '0.00',
            'tier': 'Error',
            'percentage': '0'
        }, status=400)
class PricingInfoView(LoginRequiredMixin, TemplateView):
    template_name = 'event_management/pricing_info.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['pricing_tiers'] = PricingService.get_all_tiers()
        context['free_event_allowed'] = config('FREE_EVENTS_ALLOWED', cast=bool, default=True)
        context['free_event_max_capacity'] = config('FREE_EVENT_MAX_CAPACITY', cast=int, default=30)
        context['currency'] = config('PLATFORM_CURRENCY', default='GBP')
        return context
    
